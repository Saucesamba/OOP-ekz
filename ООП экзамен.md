## 1. Структура программы на С++. Пример простейшей программы. Препроцессор

Программа на С++ складывается из команд препроцессора,блока объявления типов и констант, 
блока описания функций, основной функции, называемой main()

Препроцессор - компьютерная программа, которая удаляет из кода комментарии, преобразует код в соответствии с макросами и выполняет иные директивы, начинающиеся с символа `#` (такие как `#include`, `#define`, разнообразные директивы типа `#pragma`, `#ifndef`).

Структура консольной программы по Ивановой:
```
{команды_препроцессора}
[объявление_типов,_констант,_переменных]
{прототип функции}
{функция}
функция main()
{функция}
```
где `[]`, `{}` - часть расширенной формы Бэкуса-Наура [(приложение А)](#приложение-а-расширенная-форма-бэкуса-наура).

Пример программы на C++:

```c++
//блок команд препроцессора
#include <iostream> 
#define C = 10 // c-style константа

// Импорт всех имён из постранства имён std
using namespace std; // не является командой препроцессора

//блок объявления типов и констант, переменных
typedef struct FooBar {
    int a;
    double b;
} FooBar;
constexpr int bar = 10; // c++-style константа. constexpr означает, что значение переменной будет обязательно вычисленно во время компиляции. С const такой гарантии нет: значение может вычисляться и в рантайме. Не помню, говорила ли Иванова об этом.
int baz = 42;
class FooBaz {
    void * smth;  
};
typedef enum BarBaz { a, b, c } BarBaz;

//прототип функции
void foo();

//основная функция main()
int main() {
    foo();
    return 0;
}

//блок объявления и описания функций
void foo() { cout<<"Hello World!" }
```

Наипростейшая программа на C++:

```c++
int main() { return 0; }
```

## 2. Скалярные типы данных С++. Определение констант и переменных. Примеры определений

A: Целочисленные типы

<img src="2 вопрос 1.png"/>

Б: Вещественные типы данных

<img src="2 вопрос 2.png"/>

В: Неопределенный («пустой») тип void.

Г: Перечисляемый тип

```c++
enum {SUN, MON, TUES, FRI=5, SAT} day;
//SUN =0, MON = 1, TUES = 2, FRI=5, SAT=6

// или же
enum class Options { None, One, All }; // использование слова class ограничивает область видимостии перечесляемых значений (C++11), нужно пользоваться обязательно операцией доступа `::`
Options o = Options::All;
```

Для совместимости с Си при приведении числа к bool считается, что false - 0, true - любое число кроме 0.

## 3. Операции над скалярными данными С++. Приоритеты операций. Примеры выражений

А: Арифметические операции

```c++
int a=5;
int b=3;
int c;
c=a+b; //8 -сложение
c=b-a; //2 - вычитание
c=a*b; //15 -умножение
c=a/b; //1 (если оба числа int то результат int, если один не int то результат float (или double, смотреть в стандарт :) ))
c=a%b; //2 - остаток от деления
```

Б: Логические операции

```c++
bool a=true;
bool b=false;
bool c=false;
bool d=(((a)&&(!b))||(c)) //true
```

<br>В: Логические поразрядные - аналогично логическим, только операции выполняются над числами в их двоичном представлении</br>
<br>Г: Обычные операции сравнения (<, >, >=, <=, ==, !=)</br>
<br>Д: Сдвиговые операции </br>

```c++
unsigned int a = 2 << 2;          // 10  на два разрядов влево = 1000 - 8
unsigned int b = 16 >> 3;         // 10000 на три разряда вправо = 10 - 2
```

<br>E: Порядковые операции </br>

```c++
int a=2;
int d= a++ ; // d=2 a=3
int c= ++a ; // d=3 a=3
```

<br>Ж: Операции присваивания</br>

```
*=, +=, -=, /=, =, %=, &=, |=, ^=, <<=, >>=
```

<br>З: Тернарный оператор</br>

```c++
int a=2;
a==2? cout<<"Da" : cout<<"No"; //Da
```

<br>Приоритет оперций в С++ такой:</br>

```
1.  ( )   [ ]   ->  ::   .
2.  ! (не)  +  -  ++  --  &(переменная)  *(указатель)  sizeof  new  delete
3.  .*   ->*
4.  *   /   %
5.  +  - (бинарные)
6.   <<   >>
7.   <   <=   >   >=
8.   = =   ! =
9.   &(поразрядное и)
10.  ^(исключающее или)
11.  | (поразрядное или)
12.  &&
13.  ||
14.  ?:
15.   =   *=   /=   %=   +=   -=   &=   ^=   |=   <<=   >>=
16.  ,
```

## 4. Управляющие операторы if и switch С++. Примеры

Сказать нечего, лучше привести пример)

```c++
//пример условной операции 
if(a>b) coat<<a;
else cout<<b;
```

```c++
//пример операции switch
switch (n) {
    case 1:
        printf("Hello");
        break;
    case 2:
        printf("World!");
        break;
    default:
        printf("Saucesamba"); //выбор по умолчанию
        break;
}
```

## 5. Организация циклов в С++. Примеры

```c++
// Цикл перебора:
int k=0;
for(int i = 0; i < 5; ++i /* от авторов, рекомендуется именно такой оператор инкремента */) {
    k += i;
}
```

```c++
// Цикл while(пока):
int k = 0;
while (k < 5) {
    k++;
}
```

```c++
// Цикл do-while:
int k = 6;
do{
k--;
}while(k > 0)

// Цикл range-based-for или for по коллекции. Работает над стандартными контейнерами и массивами
for ((описание_переменной) (имя_переменной) : (имя_контейнера)) {}

vector<int> vec = {1, 2, 3};
for (const auto & num : vec) {
    cout << num;
} // 123
```

Подробнее об `const auto &` в [приложении Б](#приложение-б-синтаксис-работы-с-переменными). 

## 6. Неструктурные операторы передачи управления в С++

```c++
if (!b){
goto exit; 
}
else{
     /*...*/ 
}
exit: c="Error";
//если не, то все строки когда проигнорируются, и компилятор перейдёт к строке с меткой exit
```

```c++
while ( i < 5 )
{
    cin >> x;
    if ( x >7 ){
        cout<<"Too big number";
        continue;
    }
    y += x * x;
}
//В данном примере при x>7 будет проигнорировано все что стоит после оператора continue, и будет осуществлен переход к следующей итерации цикла
```

```c++
for(int i=0; i<n; i++)
{
    cin>>x;
    if ( x >15 )
         break;
    else y += x * x;
}
//при х>15 цикл аварийно завершится
```

## 7. Указатели и ссылки. Примеры объявлений

<br>
Указатель- переменная, в которой хранится адресс ячейки памяти (первого байта этого куска памяти).
</br>

<br>
Ссылка тоже физически представляет собой адрес, но в отличие от указателя при работе со ссылками не используется операция разыменования.
Можно сказать, что ссылки - это “псевдонимы” переменных, которые используются для работы с ними.
</br>

```c++
$ Указатель = [изменяемость_значения] Тип [изменяемость_адреса] * Имя [=Адрес]

void * a; // изменяемой адрес и данные
const int * b = new int(1); // неизменяемое значение, изменяемый указатель
int * const c = new int(2); // изменяемое значение, неизменяемый указатель
```

Простое мнемоническое правило: если `const` стоит до `*`, то относится к данным, если после -- к указателю.

Примеры:

```c++
int a,*ptri,*ptrj; 
void *b;
ptri = &a; // записали в указатель ссылку на а     
ptri = nullptr; // нулевой указатель
ptri = ptrj; // присваивание указателей
b = &a; // неявное преобразование указателя на int к указателю без типа
// явное преобразование типа указателя
ptri = (int *) b; // c-style
ptri = static_cast<int *> b; // cpp-style
// разыменование указателя
int c, a = 5, *ptri = &a;  
c = *ptri; 
*ptri=125;
```

## 8. Управление динамической памятью С++. Примеры

c++-style: 
`new (тип)` - операция выделения памяти  
`delete (типизированныйуказатель)` - операция освобождения памяти из-под объекта  
`delete[] (типизированный указатель)` - операция  освобождения памяти из-под массива  

c-style:  
`void * malloc(size_t size)` - выделение куска памяти  
`void * calloc(size_t n, size_t size)` - тоже выделение куска памяти, можно использовать для создания массивов.  
`free (void * ptr)` - освобождение куска памяти

*Если невозможно выделить указанное число байт, то операции/функции возвращают **нулевой** указатель.*

```c++
int *k;
k = new int; //операция выделения памяти
*k = 85;

int *a;   
if ((a = new int(-244)) == NULL){ 
    printf("Not enough memory.");
    exit(1);  
} 
delete a; //операция освобождения памяти

//пример со списком
int *list;   
list = new int [3]; //выделение памяти сразу на 3 объекта типа int
*list=-244;
*(list+1)=15;   
*(list+2)=-45; 
delete[] list; 
```

## 9. Адресная арифметика С++. Примеры

<img src="9 вопрос.png"/>

```c++
int arr[] = {1, 2, 3, 4, 5};                    //создаем массив на несколько элементов
int* ptr = &arr[0];                             // получаем адрес первого элемента массива
cout << ”Первый элемент: ” << *ptr << endl;     // выводим первый элемент
ptr++;                                          // увеличиваем указатель на 1
cout << ”Второй элемент: ” << *ptr << endl;     // выводим второй элемент
ptr += 2;                                       // увеличиваем указатель на 2
cout << ”Четвертый элемент: ” << *ptr << endl;  // выводим четвертый элемент
```

## 10. Массивы С++. Примеры объявлений и две технологии обработки. Пример

Индексация массивов в С++ начинается с 0.

```c++
int mas[5]={1,2,3,4,5}; //заполнение массива при объявлении
int arr[100];  //массив
int mtr[3][5]; //матрица, в памяти строки расположены одна за другой
```

### Технологии обработки массива

<br> Обработка массива циклом foreach</br>

```c++
int arr[5] = {1, 2, 3, 4, 5}; 
for(int &x : arr) { //работа ведется непосредственно с элементами массива
    x*= 2; 
} 
for(auto x:arr)  //работа ведётся с копиями элементов, при этом слово auto говорит нам что тип элементов определяется автоматически.
    cout << x << ' '; 

for(const auto &x:arr) //слово const говорит о том, что значения нельзя изменять 
    cout << x << ' ';
```

<br> Обработка массива с помощью адресной ариметики</br>

```c++
int a[5] = {1, 2, 3, 4, 5};
int *list = a; // массивы можно приводить к указателям
(list+1) // ~ &list[1]
*(list+2) // ~ list[2]
```

## 11. Строки С++. Стандартные функции, работающие со строками. Примеры

Вообще говоря, в чистом Си понятие "строка" отсутствует, однако последовательность символом можно задать, используя `char`-массивы и соответственно указатели на `char`-массивы.

**Основное отличие** от паскалевых строк заключается в внутреннем представлении строк и контроле их длины. В паскале первый байт хранит в себе длину строки, в Си же хранение длины строки не происходит, вместо этого конец строки помечается специальным нулевым символом `\0`, поэтому сишные строки ещё называют "нуль-терменированными".

Для получения длины строки Си можно использовать функцию `size_t strlen(const char *)` 

Идиоматичным для c++ является использование специального класса `string` из пространства имён `std` из библиотеки `string`, который фактически является обёрткой над строкой Си и предоставляет некоторый набор операций над такой строкой. Будьте осторожны, использование `string` вместо сишных строк может триггернуть Иванову.

Примечание от Ивановой, пунктуация сохранена.  Цикл for по коллекции для строк использовать нельзя, поскольку он не видит завершающего нуля… 

Отсебятина от Залыгина. Не знаю, кто там что не видит, но сама конструкция `range-based for` (также именуемый Ивановой как `for по коллекции`) рассахаривается в обычный `for` по итератору от объекта [с некоторыми нетривиальными особенностями](https://en.cppreference.com/w/cpp/language/range-for). Не могу сказать, как связано примечание с внутренней реализацией такого цикла.

Про строковые литералы. [Строковые литералы](https://learn.microsoft.com/ru-ru/cpp/c-language/c-string-literals?view=msvc-170) храняться в статической памяти и неизменяемы, однако на них получить указатель или ссылку. Даже при отсутствии квалификатора `const` изменить значение не получиться, хотя формально данная операция возможна. Пояснение:

```c++
char * foo = "bar"; // "bar" - строковый литерал, foo - указатель на строковый литерал.
foo[2] = 'z';
printf("%s\n", foo) // -> bar
```

При этом, если использовать массив, будет происходить копирование:

```c++
char foo[] = "bar"; // "bar" - строковый литерал, foo - массив символов, заполняется копированием из статической памяти.
foo[2] = 'z';
printf("%s\n", foo); // -> baz
```

Примеры объявления строк:

```c++
char mystr[10]; //компилятор выделит заданное кол-во памяти, не включая памяти для символа конца строки 
char str[]="hello"; //компилятор автоматически выделит нужное кол-во памяти для размещения строки + символа конца строки.
```

```c++
char *string = new char[12]; //выделяется блок памяти заданного размера.
strcpy(string, "hello"); //копируем строку в нашу переменную
delete[] string; //очищение памяти
```

Я думаю, что неплохо было бы знать некоторые основные функции для сишных строк по типу:

```c++
// Прототипы функций находятся в этих хедерах.
#include <string.h> // сишный хедер, не путать с string для c++.
#include <stdlib.h>

char * strcat(char * dest, const char * src);  // конкатенация строк, возращает результат конкантенации src к des, указатель, идентичный dest
int strcmp(const char * s1,const char * s2); // сравнение строк
char * strcpy(char * dest,const char * src); // копирование строк, возвращает результат копирования src в dest
int atoi(const char *); // строка-в-число
double atof(const char *); // строка-в-вещественное число
char * itoa(int value, char * str, int radix); // число-в-строку
```

## 12. Структурный тип С++. Пример

Структура-способ организации данных, при котором данные разных типов могут храниться как одно целое.

```c
//С-style
struct prepod { // prepod - тег структуры
    char name[7];
    int year;
}

struct prepod ivanova; // вообще говоря, тоже C-style определение структурной переменной
```

```c++
//С++ - style
typedef struct prepod { // писать prepod после struct не обязательно, но если вы хотите, чтобы оно было доступно внутри определения структуры (например, для определения рекурсивных типов), то писать необходимо.
    char name[7];
    int year;
} prepod;
```

В чем разница между этими определениями? Не помню, говорила ли об этом Иванова, но здесь кратко опишу, в чем дело, т.к. вопрос интересный. Подробно можно почитать про суть вопроса [здесь](http://microsin.net/programming/arm/struct-and-typedef-struct-difference.html).

Так вот, когда некто пишет `struct Foo {...}`, он присваивает тег `Foo` новосозданной структуре, этот тег можно использовать в дальнейшем для создания переменных данной структуры. Однако Си разрешает также определять и другие элементы с именем `Foo`, например, функции: `void Foo();`, где `Foo` уже не является тегом структуры. Данная особенность может создать путаницу, когда `Foo` является тегом, а когда - чем-то иным. Чтобы зарезервировать слово `Foo` только для структуры, необходимо использовать ключевое слово `typedef`.

```c++
//Обращение к полям структуры происходит с помощью точечной нотации, то есть:
prepod Num;
Num.old;
prepod mas[5];
mas[3].old; 

prepod *Num;
Num->old; //в данном случае у нас указатель на структуру.
```

Динамические структуры данных -- структуры, хранящие указатели.

Для структурного типа все поля является публичными.

Структурная переменная хранится в куске байт, где в той же последовательности, что и указано в определении структуры, расположены поля структуры:

<img src="./structs.png">

Возможно, стоит также сказать про union. Синтаксис объявления аналогичен:

```c++
union Foo {
    double d;
    long l;
    int k[2];
}
```

Идея в том, кусок памяти, отведенный под объединение можно интепретировать по-разному. Внутри объединения мы перечисляем то, какие разрядные сетки мы будем накладывать кусок памяти. На структуру выше выделяется 8 байт, если создать переменную `Foo foo`, то обращение `foo.d` интепретирует 8 байт как вещественное число, если же `foo.l`, то как целое число (первые 4 байта), соответственно `foo.k` - как массив двух целых чисел (4+4=8 байт). Размер объединения определяется как размер самого большого поля объединения.  

<img src="unions.png"/>

## 13. Функции С++. Передача параметров и возвращение результатов. Примеры

Функции служат для упрощения кода, путем выделения часто используемых кусков кода в отдельные подпрограммы.
Они повышают читаемость кода, а также в некоторых случаев требуют меньше памяти и времени выполнения, чем монолитный код.

<br> Примеры передачи параметров</br>

```c++
void foo(int a) //происходит передача копии значения переменной, что требует большего кол-ва памяти.
void foo(int * a) //происходит передача по ссылке непосредественно самой переменной, значение которой можно изменять.
void foo(int * a) // передаём указатель на переменную
int foo(const & a) //передача по ссылке неизменяемого значения
```

***Все параметры передаются по значению.***

Для того чтобы вернуть значение из функции, можно либо передавать в нее значение по ссылке или указателю, тогда работа будет вестись непосредственно с переменной, либо использовать служебное слово return (при этом тип возвращаемого значения должен совпадать с типом функции).

Если нужно обозначить неизменяемость параметра, то можно использовать квалификатор `const`.

Дополнительно хочу сказать про подставляемые функции (`inline`)

<img src="13 вопрос.png"/>

## 14. Параметры-массивы. Пример

```
В С++ отсутствует контроль размера массива по первому
индексу. Это означает, что если мы передаем многомерный массив в функцию, то функция должна знать размерность массива по первому индексу, чтобы правильно обрабатывать его элементы.
```

При передаче массива в функцию, компилятор передает указатель
на первый элемент массива. Таким образом, функция может
получить доступ к элементам массива, используя указатель и
индексацию.
Для передачи одномерного массива в функцию, необходимо
указать имя массива в качестве параметра функции

```c++
void print_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        std::cout << arr[i] << " "; 
    }
}
```

Чтобы передать многомерный массив в функцию, необходимо
указать количество строк и столбцов в массиве, а также
указатель на первый элемент массива. Например:

```c++
void print_matrix(int (*matrix)[3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << std::endl;
    }
}
```
От залыгина. ***Очень странный ответ, т.к. такой код является валидным:***

```c++
#include "stdio.h"

int sumsum(const int a[3][3]) {
/// или int sumsum(const int a[][3])
/// но не int sumsum(const int a[][])
  int res = 0;
  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 3; ++j) {
      res += a[i][j];
    }
  }
  return res;
}

int main() {
  int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  printf("%d", sumsum(a));
  return 0;
}
```

TODO: требуются уточнения на консультации.

## 15. Параметры-строки. Пример

Для более безопасной работы функции получающие
параметры типа «строка» целесообразно писать как
процедуры-функции.

```c++
char *strdel(const char *source,char *result)
{ char *ptr;
strcpy (result, source);
while ((ptr=strstr(result, " "))!=NULL)
strcpy(ptr,ptr+1);
return result; }
//Вызов:
strdel(str,strres);
std::cout << strdel(str,strres);
```

## 16. Параметры структуры. Пример

Для того чтобы передать структуру в подпрограмму в качестве параметра, необходимо указать в качестве типа параметра идентификатор структуры.

```c++
struct Person{
    string name;
    int age;
}
Person foo(Person &a){
    a.name="Tape";
    a.age=27;
    return a;
}
int main(){
    Person Baby;
    foo(Baby);
    std::cout<<Baby.name<<Baby.age;
    return 0;
}
```

## 17. Классы памяти переменных. Примеры

```c++
extern int a; //внешняя переменная, которая доступна во всех связанных файлах.
void foo(int a); //локальная переменная, которая перекрывает внешнюю переменную при работе функции.
```

```c++
void counter() {
  static int count = 0; 
  cout << count++;
}
int main() {
  for (int i = 0; i < 10; ++i) {
    counter();
  }
  return 0;
}
// в данной программе выделение памяти для переменной count происходит один раз, и при каждом вызове функции происходит лишь обращение к ранее скомпилированной переменной.
```

* Статические переменные хранятся в памяти все время работы программы.
* Локальные же переменны, хранятся в памяти до завершения выполнения функции.

## 18. Параметры-функции. Пример

Способ передать одну функцию в качестве аргумента
другой функции. Для этого нужно использовать
указатели на функции, которые хранят адреса функций в
памяти.

```c++
#include <iostream>
using namespace std;
// Тип для указателя на функцию, которая принимает два int и возвращает int
typedef int (*func) (int a, int b);
// Функция, которая вызывается в качестве параметра
int call_func (int a, int b) { return a + b; }
// Функция, которая принимает два int и указатель на функцию
void function (int a, int b, func f) {
int sum = f (a, b); // Вызываем функцию по указателю
cout << "Sum = " << sum << endl;
}
int main ()
{
function (5, 2, &call_func); // Передаем адрес функции call_func в качестве параметра
}
```

## 19. Правила, определяющие видимость переменных в функциях. Пример

* В С++ видимость переменных в функциях определяется блоками кода. Переменные, объявленные внутри блока кода, могут быть использованы только в этом блоке и во внутренних
блоках.
* Если переменная объявлена внутри функции, то она видна во всех блоках кода функции, но невидима за пределами функции.
* Если снаружи функции прописана глобальная переменная, которая имеет такой же идентификатор, что и переменная внутри функции, то переменная, находящаяся внутри функции, будет иметь приоритет (локальная переменная всегда перекрывает глобальную).


## 20. Пространства имен. Пример

* Пространства имен в с++ - это способ организовать код в логические группы и избежать конфликтов имен между разными функциями, классами,переменными и т.д. 
* Пространство имен представляет собой блок кода, который имеет некоторое имя и содержит различные компоненты (функции,классы, константы и т/д.).
* Для доступа к компонентам пространства имен нужно использовать его имя с оператором `::` (оператор области видимости).

```c++
// Определение пространства имен math
namespace math{
// Константа pi внутри пространства имен math
const double pi = 3.14;
// Функция square внутри пространства имен math
double square(double x) {
return x * x;
}
}
// Доступ к компонентам пространства имен math извне
double area = math::pi * math::square(5); // площадь круга с радиусом 5
```

* Существуют два основных типа пространств имен : поименованные и непоименованные
* Поименованные пространства имен имеют явное имя, которое
указывается после ключевого слова `namespace`. Они могут быть вложенными друг в друга, то естьодно пространство имен может содержать другое пространство имен.
* Для доступа к вложенному пространству имен нужно
использовать имя родительского пространства имен с оператором `::`

```c++
// Определение пространства имен console
namespace console{
// Определение вложенного пространства имен messages
namespace messages {
// Константа hello внутри вложенного пространства имен messages
const std::string hello = "Hello world!";
// Функция print_hello внутри вложенного пространства имен messages
void print_hello(){
std::cout << hello << std::endl;
}
}
}
// Доступ к компонентам вложенного пространства имен messages извне
std::cout << console::messages::hello << std::endl; // выводит Hello world!
console::messages::print_hello(); // выводит Hello world!
```

* Непоименованные пространства имен не имеют явного имени, а
обозначаются пустыми скобками после ключевого слова `namespace`.
* Непоименованные пространства имен используются для
определения переменных или функций, которые должны быть видны
только в файле, где они объявлены, то есть иметь внутреннее
связывание. Это аналогично использованию ключевого слова static
для глобальных переменных или функций.
* Непоименованные пространства имен не могут быть вложенными.

```c++
// Определение непоименованного пространства имен
namespace
{
// Переменная x внутри непоименованного пространства имен
int x = 10;
// Функция print_x внутри непоименованного пространства имен
void print_x()
{
std::cout << x << std::endl;
}
}
// Доступ к компонентам непоименованного пространства имен извне
std::cout << x << std::endl; // ошибка: x не объявлен в этой области видимости
print_x(); // ошибка: print_x не объявлен в этой области видимости
// Для доступа к компонентам непоименованного пространства имен нужно использовать
оператор :: без имени
std::cout << ::x << std::endl; // выводит 10
::print_x(); // выводит 10
// Компоненты непоименованного пространства имен не видны в других файлах программы
```

## 21. Компоновка модулей С++. Защита от повторной компиляции. Пример

<br>
Компоновка модулей - это процесс разделения программы на отдельные файлы, каждый из которых содержит определение классов, функций или переменных. Эти файлы могут быть
скомпилированы отдельно и затем объединены в единую программу.
</br>

<br>
Защита от повторной компиляции - это механизм, который предотвращает компиляцию одного и того же файла более одного раза. Это важно, потому что если файл скомпилирован
дважды, это может привести к ошибкам компоновки и неправильному поведению программы.

</br>


```c++
// Файл header.h
// Проверяем, определен ли макрос HEADER_H
#ifndef HEADER_H
// Если нет, то определяем его
#define HEADER_H
// Здесь пишем содержимое файла заголовка
// Заканчиваем блок защиты от повторной компиляции
#endif
```

Таким образом, если файл header.h будет включен несколько раз в одну единицу трансляции, то его содержимое будет скомпилировано только один раз. Это ускоряет процесс
компиляции и избегает ошибок множественных определений.

## 22. Перегрузка функций. Пример

Перегрузка функций-способ написания функций с одинаковыми именами, но для разных наборов параметров.
При этом, компилятор определяет какаую функцию вызвать по типу парааметров и их кол-ву.

```c++
int foo(int a,int b);
int foo(string a, string b);
int main(){
    string s1="Hello";
    string s2="world!";
    foo(s1,s2)//вызов функции foo() для параметров-строк
}
```

## 23. Функции с параметрами по умолчанию. Пример

Функции с параметрами по умолчанию — это функции, которые могут быть вызваны с меньшим количеством аргументов, чем параметров. В этом случае для недостающих аргументов
используются значения по умолчанию, которые указываются при объявлении или определении функции.
Функции с параметрами по умолчанию позволяют писать более гибкий и удобный код, так как можно вызывать одну и ту же функцию с разными наборами аргументов в зависимости от ситуации.
Например, можно определить функцию print, которая принимает строку для вывода и символ для заполнения пробелов, но имеет значение по умолчанию для второго параметра.
Пример функции с параметрами по умолчанию:

```c++
#include <iostream>
#include <iomanip>
#include <string>
// Функция print принимает строку s и символ c
// Значение по умолчанию для c - пробел
void print(const string& s, char c = ' ')
{
// Выводим строку s с заполнением символом c
std::cout << std::setfill(c) << std::setw(20) << s << std::endl;
}
int main()
{
// Вызываем функцию print с двумя аргументами
print("Hello", '*'); // выводит ******Hello
}
```

При использовании функции со значениями по умолчанию наиболее часто изменяемые параметры указывают в начале списка параметров, так как изменять порядок их следования нельзя.

## 24. Текстовые файлы. Отличие от Delphi Pascal. Пример

Если в Pascal можно было просто создать файловую переменную, свзяать ее с именем файла, и работать с ней с помощью стандартных команд, то в C++ для работы с файлами нужно подключить библиотеку `fstream`, создать объект класса `fstream`, и дальше вызывать его методы для работы с файлами.


```c++
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int main() {
ofstream f("test.txt"); // Создаем и открываем файл для записи
f << "Hello, world!" << endl; // Записываем строку в файл
f.close(); // Закрываем файл
ifstream f("test.txt"); // Открываем файл для чтения
string s; // Создаем переменную для хранения строки из файла
getline(f, s); // Читаем строку из файла в переменную s
cout << s << endl; // Выводим строку на экран
f.close(); // Закрываем файл
return 0;
}
```

## 25. Двоичные файлы. Отличие от Delphi Pascal. Пример

```c++
//пример записи в двоичный файл
int main() {
string str = ”Hello, world!”;
ofstream file(”ex.bin”, ios::binary); // ios::binary − компонента, показывающая, что файл будет двоичным.
if (file.is_open()){
    file.write(str.c_str(), str.size()); // с_str() – это метод, передающий указатель на первый символ строки str; str.size() – размер строки str в байтах
}
file.close();
return 0;
}
```

```russian
В данном случае данные будут записаны в файл в бинарном формате – каждый символ будет иметь свой ASCII-код. Каждый символ будет занимать один байт памяти. Вот как будет
выглядеть эта строка в шестнадцатеричном представлении (“Hello, world!”):
48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21
Здесь каждый двухзначный блок представляет один байт. Например, первый блок “48” соответствует символу ‘H’ в ASCII-кодировке.
```

## 26. Определение класса, компоненты класса. Ограничение доступа. Пример

```
Класс-пользовательский тип данных, в которых хранятся поля, а также методы, которые могут работать с этими полями.
```

В С++ отличие между структурой и классом только в том, что в структуре по умолчанию все поля public, а в классе private.

```
Компоненты класса:

Внутренние(private) - доступны только методам класса,дружестевнным функциям и дружественным классам.

Публичные (public) - доступен всем методам в программе. Исключение - если класс потом унаследован от private класса родителя.

Защищенные(protected) - недоступен из любого метода в программе, если это не friend функция или не friend-класс. Также доступен в методах унаследованного класса, но не в его екземплярах.
```

Примеры:

```c++
//private
void inc(){ //дружественная функция
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
    friend class B;
}

class B{            //дружественный класс
    void method(){
        A object;
        object+=3; //нет ошибки, так как дружественный класс
    }
}

int main(){
    A myobj;
    myobj.val; //ошибка, т.к. поле private
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки, так как inc()-дружественная функция   
}
```

```c++
//public
void inc(){
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
}

class B : private A {}

int main(){
    A myobj;
    myobj.val; //нет ошибки
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки
    B few;
    few.val=3; //ошибка, так как наследование private
}
```

```c++
//protected
void inc(){ //дружественная функция
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
    friend class B;
}

class B{            //дружественный класс
    void method(){
        A object;
        object+=3; //нет ошибки, так как дружественный класс
    }
}

int main(){
    A myobj;
    myobj.val; //ошибка, т.к. поле protected
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки, так как inc()-дружественная функция
    
}
```

## 27. Инициализация полей при отсутствии конструктора. Пример

```
Если класс не имеет явного констуктора, то создается конструктор по умолчанию (конструктор без параметров).
Тогда, при создании объекта класса можно указыватьь значения его полей в фигурных скобках.
```

```c++
class Human{
    public:
    int age;
    string name;
}
int main{
    Human Second; //экземпляр без инициализации полей
    Human first{30,"Adam"}; //экземпляр с инициализацией полей
    cout<<first.age<<first.name;
}
```

```
Также, актуально использование специальных методов класса, которые инициализируют поля (сеттеры).
```

```c++
class Human{
    public:
    int age;
    string name;
    void Init(int myage, string myName){
        age=myage;
        name=myName;
    }
}
int main{
    Human Second; //экземпляр без инициализации полей
    Human first{30,"Adam"}; //экземпляр с инициализацией полей
    Second.Init(18,"Saucesamba"); //вызов set'тера для инициализации полей
    cout<<first.age<<first.name;
}
```

## 28. Конструкторы. Инициализация полей при наличии конструктора. Пример

```
Костурктор-специальная функция, которая имеет то же имя что и класс, и служит для инициализации полей класса.

В отличие от отдельного метода инициализации полей, конструктор не создаёт полей класса с мусорными значениями, а сразу записывает в них переданное значение.

Это эффективно по потреблению памяти, а также безопасно, если поля являются объектами другого класса.

```

```c++
//пример конструктора
class A{
private:
    int x;
    int y;
public: 
    A(int a,int b): x(a), y(b) {}; //коструктор с параметрами и списком инициализации
}
```

```
Если в классе явно не указан коструктор по умолчанию (default), или нет конструкторов с параметрами, то создается констурктор по умолчанию. 
Он может использоваться для выделения памяти под объект.
```

```c++
class A{
private:
    int x;
    int y;
public:
    A(){} = default;
    A(int a; int b): x(a),y(b) {};
    A(int a; int b=100):x(a),y(b);
}
int main(){
    A(); //констурктор без параметров-выделена память под объект
    A(100,200); //обычный коструктор
    A(50); //конструктор, у которого значение поля y по умолчанию
}
```

Также существуют кострукторы перемещения и копирующие конструкторы. Подробнее о них в билетах 40,41.

## 29. Деструкторы. Пример

```
Деструктор-специальная функци, которая вызывается для удаления объекта, или когда время жизни объекта заканчивается.
Конструктор не имеет параметров и списка инициализации.
Каждый класс имеет только 1 деструктор.
```

```
Когда вызывается?
1. Завершение работы программы
2. Завершение времени жизни временного объекта.
3. Освобождение памяти с помощью delete. 
```

```c++
class A{
private:
    int x;
public:
    A(int a): x(a){cout<<"Constructor"};
    //дестуктор 
    ~A(){
        delete x; //освобождаем память поля x.
    }
}
```

Деструктор также может быть вызван явно с помощью полного имени функции деструктора. Однако это не рекомендуется делать, так как это может привести к повторному вызову деструктора или неопределенному поведению.

## 30. Инициализация полей объектов при наличии и отсутствии конструктора. Пример

`Билеты 27+28.`

## 31. Простое и множественное наследование классов. Пример

```
Наследование — это способ организовывать иерархии классов. При этом класс-наследник приобретает поля и методы базового класса, модифицируя их область видимости.
```

```c++
//пример простого наследования+пример ограничения наследования.
class A{
protected:
    int x;
public:
    A(int a):x(a) {};
}
class B final:public A{ //не сможем унаследоваться от класса В
private:
    string str;
public:
    B(int a,string mystr) : A(a), str(mystr) {};
}
```

```c++
//пример множественного наследования
class A{ 
protected: 
    int n;
public: 
    A(int an): n(an) {}
};

class B{ 
protected: 
    int m;
public:
    B(int am): m(am) {}
};

class AB :public A, public B
{ 
    int l;
public:
    AB(int an, int am, int al) :A(an), B(am), l(al) {};
    void pp() {std::cout << n << ' ' << m << ' ' << l; }
};
int main()
{ 
  AB ab(3, 4, 5);
  ab.pp();
  return 0;
}
```

<img src="31 вопрос.png"/>

## 32. Наследование. Ограничение доступа при наследовании. Пример

Видимость компонентов класса при наследовании.
<img src="32 вопрос.png"/>

`Смотри первый пример из вопроса 31.`

Также можно запретить дальнейшее наследование от данного класса с помощью служебного слова final

## 33. Конструкторы и деструкторы производных классов. Пример

Конструкторы и деструкторы базового класса можно использовать в производном.

<img src="33 вопрос.png"/>

```
При объявлении объектов производного класса всегда вызывается конструктор базового класса, используемый для инициализации наследуемых полей.

Если в списке инициализации конструктора производного класса вызов конструктора базового класса есть, то вызывается он.

Если в списке инициализации конструктора производного класса вызов конструктора базового отсутствует, то автоматически вызывается конструктор базового класса без параметров!
```

`Смотри второй пример из билета 31`

При наличии конструторов и деструторов в 2-х классах, один из которых наследуется от
другого, конструторы вызываются в прямой последовательности (сначала для базового класса, потом для производного), а деструкторы наоборот (сначала деструктор производного
класса, потом базового). 

## 34. Композиция. Пример

```
Композиция - это механизм, который позволяет создавать объекты, содержащие другие объекты в качестве своих частей. Это достигается путем включения одного класса в другой класс
в качестве его полей.

При композиции объект класса не может существовать без другого класса (жесткая привязка);
```

```c++
class Human{
public:
    void Think(){
        brain.Think();
    }
private:

    class Brain{ // Класс Brain внутри класса Human
public:
    void Think(){
        cout << ”I think” << endl;
    }
    };
    Brain brain; // Создаем объект класса Brain, чтобы вызвать его в методе Think()
};
```

## 35. Наполнение. Пример

```
Агрегация / Наполнение - это отношение между объектами, при котором один объект является частью другого объекта и при этом может существовать независимо от него (не жесткое включение).
```

```c++
class num{
private:
    int x;
public:
    void setnum(int a) { x=a; };
    int getnum () {return x;}
}
class intmas{
private:
    num mas[10];
public:
    void initmas(){
        for (int i=0;i<10;i++)
        mas[i].setnum(i);
    }
    void printmas(){
        cout<<mas[i].getnum()<<" ";
    }
}
```

То есть число может существовать в независимости от массива чисел, и его также можно использовать с другими классами.

## 36. Полиморфное наследование. Простой полиморфизм. Пример

```
Простой полиморфизм - механизм переопределения методов базового класса при наследовании в производном классе 
```

```c++
class Dog{
public:
    virtual void Print() { // виртуальный метод, так как его будем переопределять.
        cout<<"Gaw-Gaw";
    };
}

class Cow: public Dog{
public:
    void Print() override { //перекрывающий метод print
        cout<<"Moo-Moo";
    }
}
```

Простой полиморфизм происходит на этапе компиляции программы (раннее связывание), т.е.
компилятор определяет тип объекта и вызывает соответствующую реализацию метода.

## 37. Полиморфное наследование. Сложный полиморфизм. Пример

```
Сложный полиморфизм - это механизм переопределения методов, используемый для создания иерархии классов в различной функциональностью. (чаще используется вместе с абстрактными классами).

В C++ нельзя создать объект абстрактного класса!
Это логично, потому что методы абстратных классов не имеют реализации и используются в других классах, в которых они переопределяются и имеют свой собственный код-реализацию.
```

```c++
class Animal{
public:
    virtual void print() = 0; //виртуальный абстрактный метод
}

class Cat : public Animal {
public:
    void print() override {
        cout<<"Meow";
    }
}

class Bird : public Animal {
public:
    void print() override {
        cout<<"Twit";
    }
}
```

Сложный полиморфизм реализуется с помощью сложного связывания, и используется когда:

1. Есть динамические поля.
2. Если наследуемый метод вызывает переопределенный метод.
3. Процедура с полиморфным объектом.

## 38. Статические компоненты классов. Пример

Статические поля в классах - это переменные, которые принадлежат классу в целом, а не
конкретному объекту класса. Они объявляются с помощью ключевого слова `static` .

`static` переменная является общей для всех объектов класса

```c++
class Balls{
public:
    static int count;   //статическая переменная, которая будет общая для всех объектов класса Balls
    string color;
    Balls(string mycolor):color(mycolor){};
    static void print() {cout<<count;}; //статический метод, общий для всех объектов класса Balls
}
int Balls::count=5; //обращение к пространству имён класса Balls, и запись значения в поле count
int main(){
    Balls ball1("red");
    Balls::print(); //обращение к пространству имен класса Balls и вызов статического метода.
}
```

Статические методы - это методы класса, определенные при помощи того же слова `static`

Статические методы не получают параметра `this`, потому что они не оперируют конкретным объектом класса, а работают на уровне класса в целом.

## 39. Особенности работы с динамическими объектами. Пример

Основные особенности работы с динамическими объектами в C++:

1. Создание динамических объектов происходит с помощью оператора `new`. Оператор `new` возвращает указатель на выделенную область памяти, которую необходимо освободить с помощью оператора `delete`.
2. Освобождение памяти, занятой динамическим объектом, происходит с помощью оператора `delete` . Если не освободить память, занятую динамическим объектом, это приведет к утечке памяти.
3. Освобождение динамической памяти, выделенной для полей класса, происходит внутри деструктора.

```c++
class MyClass{
private:
    int num;
public:
    MyClass() { cout << ”Constructor called” << endl;}
    MyClass(int numa): num(numa){};
    void Print() { cout << num << endl;}
    ~MyClass(){
        cout << ”Destructor called” << endl;
    }
    void init(int numa) {this−>num = numa;}
};
int main(){
    MyClass *obj = new MyClass(5); // Указатель на объект (выделение памяти)
    obj−>Print(); // Вызов метода через указатель
    delete obj; //освобождение памяти из-под объекта.

    MyClass *object = new MyClass[5]; // динамический массив из 5 объектов класса MyClass
    for (int i=0;i<5;i++){            // Инициализация 5 объектов
        object[i].init(i);
    }
    for (auto i = 0; i < 5; i++){
        object[i].Print();
    }
    delete[] object; // Пишем [] чтобы освободить память всего массива, а не его первого элемент
}
```

## 40. Правило Пяти. Конструктор перемещения и операция присваивания перемещением.Пример

Эти методы являются особыми, автоматически создаваемыми компилятором в случае отсутствия их явного объявления программистом.

```
Если класс или структура определяет один из следующих методов, то они должны явным образом определять все виды методов:
1. Копирующий конструктор.
2. Конструктор перемещения.
3. Оператор присваивания.
4. Оператор присваивания перемещением.
5. Деструктор - если не используются “умные указатели”.
```

<br>
Конструктор перемещения вызывается, если параметр - временный объект: 
ClassName(ClassName && ObjectName) {...}
</br>

<br>
Оператор присваивания перемещением вызывается, если присваиваемый объект - временный: 
ClassName ClassName::operator= (ClassName&& ObjectName) {...} 
</br>

<br>
Если объект имеет физический адрес (не является временным), а требует организовать вызов
конструктора перемещения или оператор присваивания перемещением, то используют функцию move()

ClassName && std :: move (ClassName & ObjectName)
</br>

```c++
using namespace std;
class Number{ 
 private: 
    int * pnum; 
 public: 

    Number(int Num):pnum(new int(Num)){     //конструктор 
      cout<<"New, Constructor"<<endl; 
    } 

    Number(const Number &R):pnum(new int(*R.pnum)){    //копирующий конструктор
      cout<<"New, Constructor copy"<<endl; 
    }   

    Number():pnum(nullptr){}                           //конструктор без параметров

    Number& operator=(const Number &R){                 //оператор присваивания
      if (pnum!=nullptr){delete pnum;cout<<"Free"<<endl;}
      pnum=new int(*R.pnum); 
      cout<<"New Operator= copy"<<endl; 
      return *this; 
    }

    ~Number(){                                          //деструктор
     if (pnum!=nullptr){delete pnum;cout<<"Free"<<endl;}
    cout<<"Destructor"<<endl; 
    } 

    Number(Number&& R):pnum(R.pnum){                        //конструктор перемещения 
      R.pnum=nullptr; cout<<"Constructor move"<<endl; 
    } 

    Number& operator=(Number&& R){                          //оператор перемещения
      if (pnum!=nullptr){ 
        delete pnum; cout<<"Free move"<<endl; 
    } 
     pnum=R.pnum; 
     R.pnum=nullptr; cout<<"Operator= move"<<endl; 
     return *this; 
   } 
};
Number f(int a,int b) {
  Number temp(a+b); 
  return Number(move(temp)); 
} 
int main() { 
  Number A(5); 
  Number B(A); 
  Number C(move(A)); 
  Number D(6); 
  D=move(A); 
  Number F=f(6,7); 
  return 0; 
}

```

## 41. Объекты с динамическими полями. Копирующий конструктор. Пример

```c++
class MyClass{
private:
    int *data;
    int size;
public:
    MyClass(int size){
        this−>size = size;
        this−>data = new int[size];      
        for (auto i = 0; i < size; i++){  // Создаем динамический массив
            this−>data[i] = i;
        }
    }

    //Внизу копирующий конструтор, принимающий в качествепараметра объект переменную типа MyClass
    //Параметр передаем по ссылке, а не по значению. Этонужно для
        //1. Передачи оригинального объекта нашего класса, а неего копии.
        //2. Безопасного копирования динамической памяти.

    MyClass(const MyClass &other){  
        this−>size = other.size;
        this−>data = new int[size];
        for (auto i = 0; i < size; i++){
            this−>data[i] = other.data[i];
        }
    }

    void Print(){
        for (auto i = 0; i < size; i++){
            cout << data[i] << ” ”;
        }
    cout << endl;
    }

    ~MyClass(){
        delete[] data;
    }
```

## 42. Дружественные функции, методы и классы. Пример

Про дружественные функции и классы я написал в `26 вопрос`.

## 43. Переопределение операций. Пример

```
Переопределение операций - это возможность определить свою реализацию стандартных
операций для пользовательских типов данных, таких как классы.
```

Если не добавить собственную реализацию операций для пользовательских типов, то будет ошибка.

```c++
class A{
private:
    int x;
    int y;
public:
    A(){};                              //конструктор без параметров
    A(int a, int b) : x(a), y(b) {};    //конструктор
    A(A &obj){                          //копирующий конструктор
        x=obj.x; y=obj.y;
    };
    ~A();                               //деструктор
    A& A::operator=(A const &obj){      //оператор присваивания
      x=obj.x; y=obj.y;
      return *this;
    };
    A& A::operator+=(A &obj){           //переопределение оператора +=
      x+=obj.x; y+=obj.y; 
      return *this;
    }   
}
int main(){
    A point1(3,4);
    A point2(5,6);
    point1+=point2;   //point1 {8,10}
}
```

Некоторые правила:

1. Можно переопределять только операции, параметры которых – объекты.
2. Не разрешается переопределение: sizeof , ? : (тернарные операторы), # , ## , ::
(пространство имен), <класс> :: (область видимости)
3. При переопределении операций нельзя изменить ее приоритет и ассоциативность.

## 44. Шаблоны классов. Пример

Шаблон класса – обобщенное описание класса, содержащее параметры, позволяющие задавать типы используемых полей или других данных. Определяется с помощью слова `template`.

```c++
template <typename T> // Создание шаблона с произвольным типом
 class MyClass{
private:
    T value;
public:
    MyClass(T mvalue) : value(mvalue) {}; 
    void DataTypeSize(){
        cout << sizeof(value) << endl; // Выводит размер переменной в байтах
    }
 };

 int main() {
 int a = 5;
 MyClass<int> myclass(a);
 myclass.DataTypeSize(); // 4 размер int в байтах
 long long b = 10;
 MyClass<long long> myclass2(b);
 myclass2.DataTypeSize(); // 8 размер long long в байтах
 return 0;
}
```

## 45. Шаблоны функций. Пример

```c++
template <typename T> // Описание шаблона с общим типом T
T Sum(T a, T b) // Описание шаблонной функции
 {
 return a + b;
 }

int main(){
 cout << Sum(4, 10) << endl;
 cout << Sum(4.6, 9.5) << endl;
 return 0;
}
```

```c++
//пример передачи разных типов в функцию
template <typename T1, typename T2>
T1 Sum(T1 a, T2 b){
Copyright botva 66
return a + b;
}

int main(){
cout << Sum(4, 10.9) << endl;
return 0;
}
```

Шаблоны функций в C++ позволяют создавать обобщенный код, который может работать с
различными типами данных, НЕ требуя явного указания типа данных, потому что он определится автоматически при компиляции.

## 46. Организация библиотеки ввода/вывода С++. Операции извлечения и вставки. Пример

```
Операции сдвигов "<<", ">>"  в классах потоков переопределены для обозначения операций ввода-вывода с преобразованием к символьному виду или из него
```

```c++
#include <iostream>
using namespace std;
int main(){
    int age;
    cin>>age;
    cout<<"Your age: "<<age<<endl;
    return 0;
}
```
`Хз, есть ли смысл говорить в этом вопросе про флаги стандартной библиотеки iosream, но если надо - то напишу`

## 47. Организация контейнеров на классах. Пример диаграммы классов

Контейнер в C++ - это класс, который позволяет управлять коллекцией объектов разных типов. В С++ существуют стандартные контейнеры библиотеки STL, например map,list,queue и т.д. Но ГС скорее всего понадобится понимание того, как это все создается, а не умение пользоваться стандартной библиотекой.

<br> Признаки контейнеров: </br>

1. Контейнер - это объект класса, который содержит в себе объекты других классов.
2. Все классы связаны между собой.

```c++
class TElement{                     //создали абстрактный класс, от которого отнаследуем Tnum и Tchar
public:
    TElement *pre,*suc;
    TElement() { pre=suc=NULL;}
    virtual ~TElement();
    virtual void Print()=0;
};

class TSpisok {                     //создали класс-контейнер, окторый представляет собой список
private:
    TElement *first,*last,*cur;
public:
    TSpisok() {first=last=cur=NULL;}
    ~TSpisok(){
        while ((cur=Del())!=nullptr) { 
            cur->Print();    
            delete(cur);
        }  
    };

    void Add(TElement *e){
        if (first== nullptr) first=last=e;  
        else{ 
            e->suc=first;  
            first->pre=e;  
            first=e;
        }  
    };   

    TElement *First() {return cur=first;}
    TElement *Next() {return cur=cur->suc;}
    TElement *Last() {return cur=last;}
    TElement *Previous() {return cur=cur->pre;}
};

class TNum:public TElement              //класс-целое число
{ public: 
    int num;
    TNum(int n):TElement(),num(n) {}
    ~TNum() override;
    void Print() override { printf("%d ",num); };
};

class TChar:public TElement            //класс-символ
{ public: 
    char ch;
    TChar(char c):TElement(),ch(c) {}
    ~TChar() override;
    void Print() override { printf("%c ",ch); };
};

```

Советую попробовать реализовать самостоятельно подобную тему, потому что Иванова обещала спросить, и также она ждет объяснение("на пальцах") как это работает.

## 48. Организация контейнеров на шаблонах. Пример диаграммы классов

Шаблон контейнера представляет собой обобщенный класс, который использует параметр типа для определения типа элементов, которые
содержит контейнер.

```c++
#include <iostream>
#include <vector>
#include <string>

template <typename T> // Объявляем шаблон класса контейнера
class MyContainer {
private:
    vector<T> v; // Вектор для хранения элементов
public:
    void add(T x) {
        v.push_back(x); // Добавление элемента в вектор
    }
    void show() { // Вывод элементов контейнера
        cout << ”Elements in container: ”;
        for (int i = 0; i < v.size(); i++) {
            cout << v[i] << ” ”;
            }
        cout << endl;
    }
};

int main() {
    MyContainer<int> c1; // Создаем контейнер для хранения целых чисел
    c1.add(1); // Для объекта c1 шаблон будет инициализирован только int типом
    c1.add(2);
    c1.show();

    MyContainer<string> c2; // Создаем контейнер для хранения строк
    c2.add(”Hello”); // Для объекта c1 шаблон будет инициализирован только string типом
    c2.add(”world”);
    c2.show();
    return 0;
}
```

## 49. Организация интерфейса с использованием виджетов Qt. Пример

~`Ура, кринж вопросы`~
Виджет в QT - это графический элемент интерфейса пользователя, который может быть размещен на окне приложения. Виджетами могут быть кнопки, поля ввода, метки, таблицы, графики и т.д.

```c++
 #include <QApplication>
 #include <QWidget>
 #include <QLabel>
 #include <QPushButton>

 int main(int argc, char *argv[]){

 QApplication app(argc, argv);
 QWidget *window = new QWidget;
 window−>setWindowTitle(”My App”);
 QLabel *label = new QLabel(”Hello, World!”, window);
 label−>setGeometry(50, 50, 200, 50);
 QPushButton *button = new QPushButton(”Click me!”, window);
 button−>setGeometry(50, 100, 200, 50);
 QObject::connect(button, &QPushButton::clicked, [=](){
 label−>setText(”Button clicked!”);
 });
 window−>show();
 return app.exec();
 }
```

## 50. Сигналы, слоты и события Qt. Пример

~`Душно`~

Сигналы, слоты и события являются основными механизмами взаимодействия между объектами в Qt.

1. `Сигналы` - это события, которые генерируются объектом при определенных условиях.
Они могут быть переданы другим объектам, называемым слотами, для выполнения определенных действий.
2. `Слоты` - это функции, которые вызываются при получении сигнала. Они могут использоваться для выполнения любых действий, включая изменение состояния объекта или
вызов других функций.
3. `События` - это действия, которые происходят в приложении, такие как нажатие клавиши или щелчок мыши. Они могут быть обработаны объектами, которые подписались на
определенные события.

```c++
//пример создания слота
public slots:
    void onButtonClicked();
```

```c++
//пример подключения сигнала к слоту
connect(ui−>pushButton, SIGNAL(clicked()), this, SLOT(onButtonClicked()));
```

```c++
//пример реализации слота
void MainWindow::onButtonClicked(){
ui−>label−>setText(”Hello, world!”);
}
```

# Ответы на вопросы Ивановой, которые она озвучивала на лекциях

### 1. Что такое `volatile` при объявлении переменной?

<br>Грубо говоря - это ключевое слово говорит компилятору о том, что надо каждый раз загружать переменную из памяти, так как ее значение может быть изменено в любой момент времени.</br>

Если не объявить `volatile`, то компилятор оптимизирует использование памяти, и будет подставлять ранее скомпилированное (с каким-то числом) глобальное значение, тем самым проверка будет всегда выдавать `true`.

```c++
const MAX_COUNT_PEOPLE = 4;
volatile int countPeole = 0;
/*...*/ 
if(countPeople > MAX_COUNT_PEOPLE)
{
    // Выдаем предупреждение
}
// Значение переменной countPeople к примеру будет меняться в другом месте 
```

### 2. В каких случаях использование копирующего конструктора обязательно?

```
Конструктор копирования необходимо использовать в тех классах, где осуществляется динамическое выделение памяти для данных. Другими словами, если в классе есть указатель, для которого память выделяется динамически с помощью оператора `new` (или других функций), то такой класс обязательно должен иметь конструктор копирования.
```

### 3. Нарисовать простейший пример контейнера-двусвязного списка.

<img src="3 доп.png"/>

### 4. Что такое виртуальное и множественное наследование?

```
Про множественное наследование упомянуто в вопросе 31.
Виртуальное множественное наследование применяется, когда наследование происходит от 2-х классов, производных от 1-го класса.
```
<img src="4 доп.png"/>

```c++
#include <iostream>
using namespace std;

class TA
{ protected:   int Fix;
public:
  TA(){ cout << "Inside A\n"; }
  TA(int  fix) :Fix(fix) { cout << "Inside TA\n"; }
};

class TB :virtual public TA
{ public: int One;
TB(int one):One(one) { cout << "Inside TB\n"; }
};

class TC : virtual public TA
{ public:int Two;
	TC(int two):Two(two) { cout << "Inside TC\n"; }
};

class TD :public TB, public TC
{ public:
	TD(int f,int one,int two) :TA(f),TB(one),TC(two)
	{ cout << "Inside TD\n"; }
	void Out() { cout << Fix; }
};

int main()                           //Inside TA int
{ TD obj(10,1,2);                    //Inside TB
	obj.Out();                       //Inside TC
	return 0;                        //Inside TD
                                     //10
}                                                                                              
```
<img src="4 доп1.png"/>

### 5. Что такое статическое поле и каким свойством оно обладает?

`вопрос 38`

### 6. Что такое шаблон?

`вопрос 44`

### 7. Объяснить как работает контейнер (дополнение к вопросу 3)

ГС рекомендовала рисовать рисунок, и на нём объяснять работу контейнера, а не пытаться объяснить на словах.

### 8. Что такое контейнер?

Контейнер в C++ - это класс, который позволяет управлять коллекцией объектов разных типов.
`47 вопрос`

### 9.  Признаки контейнера?

Признаки контейнеров:

1. Контейнер - это объект класса, который содержит в себе объекты других классов.
2. Все классы связаны между собой.

### 10.  Какие ограничения существуют на переопределение операций вставки и извлечения для объектов пользовательских классов?

//TODO

### 11.  В каком представлении попадают данные к пользователю при работе с файлами(что-то такое)?

При работе с файлами выполнение операций происходит с внутренним представлением числа, а пользователю данные попадают в символьном представлении.

### 12.  Что такое внутреннее представление числа?

Губарь момент.

```
Внутренее представление числа - это представление его в виде, понятном машине, то есть в виде двоичного кода.
То есть. к примеру есть число 234. Его внутренним представлением в двухбайтовой ячейке будет 0000 0000 1110 1010. Шеснадцатеричная форма внутреннего представления: 00ЕА.
```

### 13.  Как передаются данные в функцию?

Передача данных в функцию может производиться по ссылке/указателю и по значению. При передаче по ссылке/указателю работа ведется непосредственно с самой переменной. При передаче по значению создается копия переменной, с которой и работает функция.

### 14. Синхронные и асинхронные аварийные ситуации

* Синхронные исключения – могут возникнуть только в определённых, заранее известных точках программы. Например, ошибка чтения файла или переполнение памяти.
* Асинхронные исключения могут возникать в любой момент времени и не зависят от того, какую конкретно инструкцию программы выполняет система. Например, аварийный отказ питания или поступление новых данных.
* Синхронные исключения можно предусмотреть, асинхронные – предусмотреть невозможно!

Что делать?

1. Автоматическое – выдать системное сообщение об ошибке и аварийно завершить программу без сохранения данных;
2. Программируемое:
если ошибка предусмотрена (только синхронная), то можно :
по возможности сохранить данные, выдать уточненное сообщение об ошибке и прервать выполнение программы – обработка без возврата;
"исправить" ошибку и продолжить работу – обработка с возвратом;
если используется механизм исключений, то можно перехватить уже возникшую аварийную ситуацию (в том числе асинхронную), предоставить возможность пользователю изменить данные и продолжить выполнение программы с исправленными данными – обработка с возвратом.

### 15. Исключения С/С++

//TODO

### 16. Почему не обрабатывает исключения С (что-то такое, точно не записал)

//TODO

### 17. Умные указатели, объяснение на уровне понятий

//TODO

### 18. Когда обрабатываются шаблоны во время работы программы? 

Шаблоны обрабатываются во время работы препроцессора. (Со слов ГС)

# Аппендиксы

## Приложение А. Расширенная форма Бэкуса-Наура

//TODO

## Приложение Б. Синтаксис работы с переменными

//TODO