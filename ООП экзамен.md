## 1. Структура программы на С++. Пример простейшей программы. Препроцессор

```
Программа на С++ складывается из команд препроцессора,блока объявления типов и констант, блока описания функций, основной функции, называемой main()
```

```
Препроцессор-компьютерная программа,которая удаляет из кода комментарии, преобразует код в соответствии с макросами и выполняет иные директивы, начинающиеся с символа «#» (такие как #include, #define, разнообразные директивы типа #pragma).
```

Пример простейшей программы на C++

```c++
   //блок команд препроцессора
   #include <iostream> 
   using namespace std 
   //блок объявления типов и констант
   #DEFINE C=10
   //блок объявления и описания функций
   void foo() {cout<<"Hello World!"}
   //основная функция main()
   int main() {
    foo();
    return 0;
   }
```

## 2. Скалярные типы данных С++. Определение констант и переменных. Примеры определений

A: Целочисленные типы
Б:

## 3. Операции над скалярными данными С++. Приоритеты операций. Примеры выражений

А: Арифметические операции

```c++
int a=5;
int b=3;
int c;
c=a+b; //8 -сложение
c=b-a; //2 - вычитание
c=a*b; //15 -умножение
c=a/b; //1 (если оба числа int то результат int, если один не int то результат float)
c=a%b; //2 - остаток от деления
```

Б: Логические операции

```c++
bool a=true;
bool b=false;
bool c=false;
bool d=(((a)&&(!b))||(c)) //true
```

<br>В: Логические поразрядные-аналогично логическим, только операции выполняются над числами в их двоичном представлении</br>
<br>Г: Обычные операции сравнения (<, >, >=, <=, ==, !=)</br>
<br>Д: Сдвиговые операции </br>

```c++
unsigned int a = 2 << 2;          // 10  на два разрядов влево = 1000 - 8
unsigned int b = 16 >> 3;         // 10000 на три разряда вправо = 10 - 2
```

<br>E: Порядковые операции </br>

```c++
int a=2;
int d= a++ ; // d=2 a=3
int c= ++a ; // d=3 a=3
```

<br>Ж: Операции присваивания</br>

```
*=, +=, -=, /=, =, %=, &=, |=, ^=, <<=, >>=
```

<br>З: Тернарный оператор</br>

```c++
int a=2;
a==2? cout<<"Da" : cout<<"No"; //Da
```

<br>Приоритет оперций в С++ такой:</br>

```
1.  ( )   [ ]   ->  ::   .
2.  ! (не)  +  -  ++  --  &(адрес)  *(указатель)  sizeof new   delete
3.  .*   ->*
4.  *   /   %
5.  +  - (бинарные)
6.   <<   >>
7.   <   <=   >   >=
8.   = =   ! =
9.   &(поразрядное и)
10.  ^(исключающее или)
11.  | (поразрядное или)
12.  &&
13.  ||
14.  ?:
15.   =   *=   /=   %=   +=   -=   &=   ^=   |=   <<=   >>=
16.  ,
```

## 4. Управляющие операторы if и switch С++. Примеры

Сказать нечего, лучше привести пример)

```c++
if(a>b) coat<<a;
else cout<<b;
```

```c++
switch (n):
{
case 1: printf("Hello");
case 2: printf("World!");
default: printf("Saucesamba"); //выбор по умолчанию
}
```

## 5. Организация циклов в С++. Примеры

Цикл перебора:

```c++
int k=0;
for(int i=0;i<5;i++){
    k+=i;
}
```

Цикл while(пока):

```c++
int k=0;
while (k<5){
    k++;
}
```

Цикл do-while:

```c++
int k=6;
do{
k--;
}while(k>0)
```

## 6. Неструктурные операторы передачи управления в С++

Да-да, те самые, которыми нельзя пользоваться)

```c++
if (!b){
goto exit; 
}
else{
     /*...*/ 
}
exit: c="Error";
```

В данном примере при x>7 будет проигнорировано все что стоит после оператора continue, и будет осуществлен переход к следующей итерации цикла

```c++
while ( i < 5 )
{
    cin>>x;
    if ( x >7 ){
        cout<<"Too big number";
        continue;
    }
    y += x * x;
}
```

```c++
for(int i=0; i<n; i++)
{
    cin>>x;
    if ( x >15 )
         break;
    else y += x * x;
}
```

## 7. Указатели и ссылки. Примеры объявлений

```
Указатель- переменная, в которой хранится адресс ячейки памяти.
```

```
Ссылка тоже физически представляет собой адрес, но в отличие от указателя при работе со ссылками не используется операция разыменования.
```

Примеры:

```c++
int a,*ptri,*ptrj; 
void *b;
ptri = &a; //записали в указатель ссылку на а     
ptri = nullptr; // нулевой указатель
ptri = ptrj; //присваивание указателей
b = &a; //неявное преобразование указателю без типа к типу int
//явное преобразование типа указателя
ptri = (int *) b; //С-style
ptri = static_cast<int *> b; //C++ - style
//разыменование указателя
int c, a = 5, *ptri = &a;  
c = *ptri; 
*ptri=125;
```

## 8. Управление динамической памятью С++. Примеры

```c++
int *k;
  k = new int; //операция выделения памяти
  *k = 85;

int *a;   
  if ((a = new int(-244)) == NULL){ 
    printf("Not enough memory.");
         exit(1);  } 
  delete a; //операция освобождения памяти

//пример со списком
int *list;   
 list = new int [3]; //выделение памяти сразу на 3 объекта типа int
 *list=-244;
 *(list+1)=15;   
 *(list+2)=-45; 
 delete[] list; 
```

## 9. Адресная арифметика С++. Примеры

надо вставить фотку с презы 2 слайд 5

## 10. Массивы С++. Примеры объявлений и две технологии обработки. Пример

```c++
int mas[5]={1,2,3,4,5}; //заполнение массива при объявлении
int arr[100];  //массив
int mtr[3][5]; //матрица
```

### Технологии обработки массива

<br> Обработка массива циклом foreah</br>

```c++
int arr[5] = {1, 2, 3, 4, 5}; 
for(int &x : arr) { //работа ведется непосредственно с элементами массива
    x*= 2; 
} 
for(auto x:arr)  //работа ведётся с копиями элементов, при этом слово auto говорит нам что тип элементов определяется автоматически.
    cout << x << ' '; 

for(const auto &x:arr) //слово const говорит о том, что значения нельзя изменять 
    cout << x << ' ';
```

<br> Обработка массива с помощью адресной ариметики</br>

```c++
int *list;
(list+1) // ~ &list[1]
*(list+2) // ~ list[2]
```

## 11. Строки С++. Стандартные функции, работающие со строками. Примеры

<br>
Строка-массив символов типа char, концом которой служит символ \0.
Примеры объявления строк:
</br>

```c++
char mystr[10]; //компилятор выделит заданное кол-во памяти, не включая памяти для символа конца строки 
char str[]="hello"; //компилятор автоматически выделит нужное кол-во памяти для размещения строки + символа конца строки.
```

```c++
char *string = new char[12]; //выделяется блок памяти заданного размера.
strcpy(string, "hello"); //копируем строку в нашу переменную
delete[] string; //очищение памяти
```

```
Я думаю, что неплохо было бы знать некоторые основные функцции по типу: 
strcat (конкатенация строк)
strcmp (сравнение строк)
strcpy(копирование строк)
```

## 12. Структурный тип С++. Пример

Структура-способо организации данных, при котором данные разных типов могут храниться как одно целое.

```c
//С-style
struct prepod {
    char name[7];
    int year;
}
```

```c++
//С++ - style
typedef struct {
    char name[7];
    int year;
} prepod;
```

```c++
//Обращение к полям структуры происходит с помощью точечной нотации, то есть:
prepod.old;
prepod[i].old; 
prepod->old; //в данном случае структура-это элемент связанного списка.
```

## 13. Функции С++. Передача параметров и возвращение результатов. Примеры

Функции служат для упрощения кода, путем выделения часто используемых кусков кода в отдельные подпрограммы.
Они повышают читаемость кода, а также в некоторых случаев требуют меньше памяти и времени выполнения, чем монолитный код.

<br> Примеры передачи параметров</br>

```c++
void foo(int a) //происходит передача копии значения переменной, что требует большего кол-ва памяти.
void foo(int &a) //происходит передача непосредественно самой переменной, значение которой можно изменять.
void foo(int *a) // передаём указатель на переменную
int foo(const &a) //передача по ссылке неизменяемого значения
```

```
Для того чтобы вернуть значение из функции, можно либо передавать в нее значение по ссылке или по указателю, тогда работа будет вестись непосредственно с переменной, либо использовать служебное слово return (при этом тип возвращаемого значения должен совпадать с типом функции).
```

## 14. Параметры-массивы. Пример

<br>
Какие-то кринж вопросы с этой передачей в функцию...
</br>

```
В С++ отсутствует контроль размера массива по первому
индексу
```

При передаче массива в функцию, компилятор передает указатель
на первый элемент массива. Таким образом, функция может
получить доступ к элементам массива, используя указатель и
индексацию.
Для передачи одномерного массива в функцию, необходимо
указать имя массива в качестве параметра функции

```c++
void print_array(int arr[], int size) {
for (int i = 0; i < size; i++) {
std::cout << arr[i] << " "; }
}
```

Чтобы передать многомерный массив в функцию, необходимо
указать количество строк и столбцов в массиве, а также
указатель на первый элемент массива. Например:

```c++
void print_matrix(int (*matrix)[3], int rows) {
for (int i = 0; i < rows; i++) {
for (int j = 0; j < 3; j++) {
std::cout << matrix[i][j] << " ";
}
std::cout << std::endl;
}
}
```

## 15. Параметры-строки. Пример

Для более безопасной работы функции получающие
параметры типа «строка» целесообразно писать как
процедуры-функции.

```c++
char *strdel(const char *source,char *result)
{ char *ptr;
strcpy (result, source);
while ((ptr=strstr(result, " "))!=NULL)
strcpy(ptr,ptr+1);
return result; }
//Вызов:
strdel(str,strres);
std::cout << strdel(str,strres);
```

## 16. Параметры структуры. Пример

## 17. Классы памяти переменных. Примеры

```c++
extern int a; //внешняя переменная, которая доступна во всех местах программы
void foo(int a); //локальная переменная, которая перекрывает внешнюю переменную при работе процедуры
```

```c++
void counter() {
  static int count = 0; 
  cout << count++;
}
int main() {
  for (int i = 0; i < 10; ++i) {
    counter();
  }
  return 0;
}
// в данной программе выделение памяти для переменно count происходит один раз, и при каждом вызове функции происходит лишь обращение к ранее скомпилированной переменной.
```

## 18. Параметры-функции. Пример

Способ передать одну функцию в качестве аргумента
другой функции. Для этого нужно использовать
указатели на функции, которые хранят адреса функций в
памяти.

```c++
#include <iostream>
using namespace std;
// Тип для указателя на функцию, которая принимает два int и возвращает int
typedef int (*func) (int a, int b);
// Функция, которая вызывается в качестве параметра
int call_func (int a, int b) { return a + b; }
// Функция, которая принимает два int и указатель на функцию
void function (int a, int b, func f) {
int sum = f (a, b); // Вызываем функцию по указателю
cout << "Sum = " << sum << endl;
}
int main ()
{
function (5, 2, &call_func); // Передаем адрес функции call_func в качестве параметра
}
```

## 19. Правила, определяющие видимость переменных в функциях. Пример

## 20. Пространства имен. Пример

Пространства имен в с++ - это способ организовать код в логические группы и избежать конфликтов имен между разными функциями, классами,переменными и т.д. Пространство имен представляет собой блок кода, который имеет некоторое имя и содержит различные компоненты (функции,классы, константы и т/д.). Для доступа к компонентам пространства имен нужно использовать его имя с оператором :: (оператор области видимости).
Например:

```c++
// Определение пространства имен math
namespace math{
// Константа pi внутри пространства имен math
const double pi = 3.14;
// Функция square внутри пространства имен math
double square(double x) {
return x * x;
}
}
// Доступ к компонентам пространства имен math извне
double area = math::pi * math::square(5); // площадь круга с радиусом 5
```

Существуют два основных типа пространств имен:поименованные и непоименованные
Поименованные пространства имен имеют явное имя, которое
указывается после ключевого слова namespace. Поименованные
пространства имен могут быть вложенными друг в друга, то есть
одно пространство имен может содержать другое пространство
имен. Для доступа к вложенному пространству имен нужно
использовать имя родительского пространства имен с оператором ::.
Например:

```c++
// Определение пространства имен console
namespace console{
// Определение вложенного пространства имен messages
namespace messages {
// Константа hello внутри вложенного пространства имен messages
const std::string hello = "Hello world!";
// Функция print_hello внутри вложенного пространства имен messages
void print_hello(){
std::cout << hello << std::endl;
}
}
}
// Доступ к компонентам вложенного пространства имен messages извне
std::cout << console::messages::hello << std::endl; // выводит Hello world!
console::messages::print_hello(); // выводит Hello world!
```

Непоименованные пространства имен не имеют явного имени, а
обозначаются пустыми скобками после ключевого слова namespace.
Непоименованные пространства имен используются для
определения переменных или функций, которые должны быть видны
только в файле, где они объявлены, то есть иметь внутреннее
связывание. Это аналогично использованию ключевого слова static
для глобальных переменных или функций. Непоименованные
пространства имен не могут быть вложенными. Например:

```c++
// Определение непоименованного пространства имен
namespace
{
// Переменная x внутри непоименованного пространства имен
int x = 10;
// Функция print_x внутри непоименованного пространства имен
void print_x()
{
std::cout << x << std::endl;
}
}
// Доступ к компонентам непоименованного пространства имен извне
std::cout << x << std::endl; // ошибка: x не объявлен в этой области видимости
print_x(); // ошибка: print_x не объявлен в этой области видимости
// Для доступа к компонентам непоименованного пространства имен нужно использовать
оператор :: без имени
std::cout << ::x << std::endl; // выводит 10
::print_x(); // выводит 10
// Компоненты непоименованного пространства имен не видны в других файлах программы
```

## 21. Компоновка модулей С++. Защита от повторной компиляции. Пример

Компоновка модулей C++ — это процесс связывания разных
файлов реализации и заголовков в один исполняемый файл.
Компоновка модулей C++ может быть сложной и вызывать
различные ошибки, такие как неопределенные ссылки,
множественные определения или нарушения правил однократного
определения. Чтобы избежать этих ошибок, нужно соблюдать
некоторые правила и соглашения при организации кода на C++.
Одно из таких соглашений — это защита от повторной
компиляции (include guard). Защита от повторной компиляции
предотвращает повторное включение одного и того же файла
заголовка в одну единицу трансляции. Это может произойти, если
файл заголовка включает другой файл заголовка, который уже был
включен ранее. Повторное включение файла заголовка может
привести к множественным определениям переменных или функций,
которые нарушают правило однократного определения.
Защита от повторной компиляции обычно реализуется с помощью
директив препроцессора #ifndef, #define и #endif. Эти директивы
проверяют, определен ли некоторый макрос, который служит
уникальным идентификатором файла заголовка. Если макрос не
определен, то препроцессор включает содержимое файла заголовка
и определяет макрос. Если макрос уже определен, то препроцессор
пропускает содержимое файла заголовка.
Пример защиты от повторной компиляции:

```c++
// Файл header.h
// Проверяем, определен ли макрос HEADER_H
#ifndef HEADER_H
// Если нет, то определяем его
#define HEADER_H
// Здесь пишем содержимое файла заголовка
// Заканчиваем блок защиты от повторной компиляции
#endif
```

Таким образом, если файл header.h будет включен несколько раз в
одну единицу трансляции, то его содержимое будет скомпилировано
только один раз. Это ускоряет процесс компиляции и избегает
ошибок множественных определений.

## 22. Перегрузка функций. Пример

Перегрузка функций-способ написания функций с одинаковыми именами, но для разных наборов параметров.
При этом, компилятор определяет какаую функцию вызвать по типу парааметров и их кол-ву.

```c++
int foo(int a,int b);
int foo(string a, string b);
int main(){
    string s1="Hello";
    string s2="world!";
    foo(s1,s2)//вызов функции foo() для параметров-строк
}
```

## 23. Функции с параметрами по умолчанию. Пример

Функции с параметрами по умолчанию — это функции, которые могут быть вызваны с меньшим количеством аргументов, чем параметров. В этом случае для недостающих аргументов
используются значения по умолчанию, которые указываются при объявлении или определении функции.
Функции с параметрами по умолчанию позволяют писать более гибкий и удобный код, так как можно вызывать одну и ту же функцию с разными наборами аргументов в зависимости от ситуации.
Например, можно определить функцию print, которая принимает строку для вывода и символ для заполнения пробелов, но имеет значение по умолчанию для второго параметра.
Пример функции с параметрами по умолчанию:

```c++
#include <iostream>
#include <iomanip>
#include <string>
// Функция print принимает строку s и символ c
// Значение по умолчанию для c - пробел
void print(const string& s, char c = ' ')
{
// Выводим строку s с заполнением символом c
std::cout << std::setfill(c) << std::setw(20) << s << std::endl;
}
int main()
{
// Вызываем функцию print с двумя аргументами
print("Hello", '*'); // выводит ******Hello
}
```

При использовании функции со значениями по умолчанию наиболее часто изменяемые параметры указывают в начале списка параметров, так как изменять порядок их следования нельзя.

## 24. Текстовые файлы. Отличие от Delphi Pascal. Пример

>Если в Pascal можно было просто создать файловую переменную, свзяать ее с именем файла, и работать с ней с помощью стандартных команд, то в C++ для работы с файлами нужно подключить библиотеку `fstream`, создать объект класса `fstream`, и дальше вызывать его методы для работы с файлами.
>>Либо можно навернуть говна с работой с файлами в C-style.

```c++
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int main() {
ofstream f("test.txt"); // Создаем и открываем файл для записи
f << "Hello, world!" << endl; // Записываем строку в файл
f.close(); // Закрываем файл
ifstream f("test.txt"); // Открываем файл для чтения
string s; // Создаем переменную для хранения строки из файла
getline(f, s); // Читаем строку из файла в переменную s
cout << s << endl; // Выводим строку на экран
f.close(); // Закрываем файл
return 0;
}
```

## 25. Двоичные файлы. Отличие от Delphi Pascal. Пример

## 26. Определение класса, компоненты класса. Ограничение доступа. Пример
```
Класс-пользовательский тип данных, в которых хранятся поля, а также методы, которые могут работать с этими полями.
```
В С++ отличие между структурой и классом только в том, что в структуре по умолчанию все поля public, а в классе private.
```
Компоненты класса:

Внутренние(private) - доступны только методам класса,дружестевнным функциям и дружественным классам.

Публичные (public) - доступен всем методам в программе. Исключение - если класс потом унаследован от private класса родителя.

Защищенные(protected) - недоступен из любого метода в программе, если это не friend функция или не friend-класс. Также доступен в методах унаследованного класса, но не в его екземплярах.
```
Примеры:
```c++
//private
void inc(){ //дружественная функция
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
    friend class B;
}

class B{            //дружественный класс
    void method(){
        A object;
        object+=3; //нет ошибки, так как дружественный класс
    }
}

int main(){
    A myobj;
    myobj.val; //ошибка, т.к. поле private
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки, так как inc()-дружественная функция   
}
```

```c++
//public
void inc(){
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
}

class B : private A {}

int main(){
    A myobj;
    myobj.val; //нет ошибки
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки
    B few;
    few.val=3; //ошибка, так как наследование private
}
```

```c++
//protected
void inc(){ //дружественная функция
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
    friend class B;
}

class B{            //дружественный класс
    void method(){
        A object;
        object+=3; //нет ошибки, так как дружественный класс
    }
}

int main(){
    A myobj;
    myobj.val; //ошибка, т.к. поле protected
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки, так как inc()-дружественная функция
    
}
```

## 27. Инициализация полей при отсутствии конструктора. Пример

```
Если класс не имеет явного констуктора, то создается конструктор по умолчанию (конструктор без параметров).
Тогда, при создании объекта класса можно указыватьь значения его полей в фигурных скобках.
```

```c++
class Human{
    public:
    int age;
    string name;
}
int main{
    Human Second; //экземпляр без инициализации полей
    Human first{30,"Adam"}; //экземпляр с инициализацией полей
    cout<<first.age<<first.name;
}
```

```
Также, актуально использование специальных методов класса, которые инициализируют поля (сеттеры).
```

```c++
class Human{
    public:
    int age;
    string name;
    void Init(int myage, string myName){
        age=myage;
        name=myName;
    }
}
int main{
    Human Second; //экземпляр без инициализации полей
    Human first{30,"Adam"}; //экземпляр с инициализацией полей
    Second.Init(18,"Saucesamba"); //вызов set'тера для инициализации полей
    cout<<first.age<<first.name;
}
```

## 28. Конструкторы. Инициализация полей при наличии конструктора. Пример

```
Костурктор-специальная функция, которая имеет то же имя что и класс, и служит для инициализации полей класса.

В отличие от отдельного метода инициализации полей, конструктор не создаёт полей класса с мусорными значениями, а сразу записывает в них переданное значение.

Это эффективно по потреблению памяти, а также безопасно, если поля являются объектами другого класса.

```
```c++
//пример конструктора
class A{
private:
    int x;
    int y;
public: 
    A(int a,int b): x(a), y(b) {}; //коструктор с параметрами и списком инициализации
}
```

```
Если в классе явно не указан коструктор по умолчанию (default), или нет конструкторов с параметрами, то создается констурктор по умолчанию. 
Он может использоваться для выделения памяти под объект.
```

```c++
class A{
private:
    int x;
    int y;
public:
    A(){} = default;
    A(int a; int b): x(a),y(b) {};
    A(int a; int b=100):x(a),y(b);
}
int main(){
    A(); //констурктор без параметров-выделена память под объект
    A(100,200); //обычный коструктор
    A(50); //конструктор, у которого значение поля y по умолчанию
}
```
Также существуют кострукторы перемещения и копирующие конструкторы. Подробнее о них в билетах 40,41.

## 29. Деструкторы. Пример
```
Деструктор-специальная функци, которая вызывается для удаления объекта, или когда время жизни объекта заканчивается.
Конструктор не имеет параметров и списка инициализации.
Каждый класс имеет только 1 деструктор.
```

```
Когда вызывается?
1. Завершение работы программы
2. Завершение времени жизни временного объекта.
3. Освобождение памяти с помощью delete. 
```

```c++
class A{
private:
    int x;
public:
    A(int a): x(a){cout<<"Constructor"};
    //дестуктор 
    ~A(){
        delete x; //освобождаем память поля x.
    }
}
```
Деструктор также может быть вызван явно с помощью полного имени функции деструктора. Однако это не рекомендуется делать, так как это может привести к повторному вызову деструктора или неопределенному поведению.

## 30. Инициализация полей объектов при наличии и отсутствии конструктора. Пример

`Билеты 27+28.`

## 31. Простое и множественное наследование классов. Пример

```
Наследование — это способ организовывать иерархии классов. При этом класс-наследник приобретает поля и функции базового класса, модифицируя их область видимости.
```

```c++
//пример простого наследования+пример ограничения наследования.
class A{
protected:
    int x;
public:
    A(int a):x(a) {};
}
class B final:public A{ //не сможем унаследоваться от класса В
private:
    string str;
public:
    B(int a,string mystr) : A(a), str(mystr) {};
}
```

```c++
//пример множественного наследования
class A{
protected:
    int x;
public:
    A(int a):x(a){};
}
class B :public A{
protected:
    int age;
public:
    B(int a,int mage): A(a), age(mage){};
}
class C: protected B{
private:
    string fam;
public:
    C(int a,int mage, string mfam): B(a,mage),fam(mfam){};
}
```

## 32. Наследование. Ограничение доступа при наследовании. Пример

Видимость компонентов класса при наследовании.
<img src="32 вопрос.png"/>


`Смотри первый пример из вопроса 31.`

Также можно запретить дальнейшее наследование от данного класса с помощью служебного слова final

## 33. Конструкторы и деструкторы производных классов. Пример

Конструкторы и деструкторы базового класса можно использовать в производном.

<img src="33 вопрос.png"/>

```
При объявлении объектов производного класса всегда вызывается конструктор базового класса, используемый для инициализации наследуемых полей.

Если в списке инициализации конструктора производного класса вызов конструктора базового класса есть, то вызывается он.

Если в списке инициализации конструктора производного класса вызов конструктора базового отсутствует, то автоматически вызывается конструктор базового класса без параметров!
```

`Смотри второй пример из билета 31`

## 34. Композиция. Пример

```
Композиция - это механизм, который позволяет создавать объекты, содержащие другие объекты в качестве своих частей. Это достигается путем включения одного класса в другой класс
в качестве его полей.

При композиции объект класса не может существовать без другого класса (жесткая привязка);
```

```c++
//тут должен быть пример компоиции
```

## 35. Наполнение. Пример

```
Агрегация / Наполнение - это отношение между объектами, при котором один объект является частью другого объекта и при этом может существовать независимо от него (не жесткое включение).
```

```c++
class num{
private:
    int x;
public:
    void setnum(int a) { x=a; };
    int getnum () {return x;}
}
class intmas{
private:
    num mas[10];
public:
    void initmas(){
        for (int i=0;i<10;i++)
        mas[i].setnum(i);
    }
    void printmas(){
        cout<<mas[i].getnum()<<" ";
    }
}
```

То есть число может существовать в независимости от массива чисел, и его также можно использовать с другими классами.


## 36. Полиморфное наследование. Простой полиморфизм. Пример

```
Простой полиморфизм - механизм переопределения методов базового класса при наследовании в производном классе 
```

```c++
class Dog{
public:
    virtual void Print() { // виртуальный метод, так как его будем переопределять.
        cout<<"Gaw-Gaw";
    };
}
class Cow: public Dog{
public:
    void Print() override { //перекрывающий метод print
        cout<<"Moo-Moo";
    }
}
```

Простой полиморфизм происходит на этапе компиляции программы (раннее связывание), т.е.
компилятор определяет тип объекта и вызывает соответствующую реализацию метода.

## 37. Полиморфное наследование. Сложный полиморфизм. Пример

```
Сложный полиморфизм - это механизм переопределения методов, используемый для создания иерархии классов в различной функциональностью. (чаще используется вместе с абстрактными классами).

В C++ нельзя создать объект абстрактного класса!* Это логично, потому что методы абстратных классов не имеют реализации и используются в других классах, в которых они переопределяются и имеют свой собственный код-реализацию.
```

```c++
class Animal{
public:
    virtual void print() = 0; //виртуальный абстрактный метод
}

class Cat : public Animal {
public:
    void print() override {
        cout<<"Meow";
    }
}

class Bird : public Animal {
public:
    void print() override {
        cout<<"Twit";
    }
}
```

Сложный полиморфизм реализуется с помощью сложного связывания, и используется когда:

1. Есть динамические поля.
2. Если наследуемый метод вызывает переопределенный метод.
3. Процедура с полиморфным объектом.

## 38. Статические компоненты классов. Пример

## 39. Особенности работы с динамическими объектами. Пример

## 40. Правило Пяти. Конструктор перемещения и операция присваивания перемещением.Пример

## 41. Объекты с динамическими полями. Копирующий конструктор. Пример

## 42. Дружественные функции, методы и классы. Пример

## 43. Переопределение операций. Пример

## 44. Шаблоны классов. Пример

## 45. Шаблоны функций. Пример

## 46. Организация библиотеки ввода/вывода С++. Операции извлечения и вставки. Пример

## 47. Организация контейнеров на классах. Пример диаграммы классов

## 48. Организация контейнеров на шаблонах. Пример диаграммы классов

## 49. Организация интерфейса с использованием виджетов Qt. Пример

## 50. Сигналы, слоты и события Qt. Пример
